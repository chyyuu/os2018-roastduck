# Lab 7 Report

## 练习1

为实现内核级信号量，μCore首先为每个信号量实现了一个`wait_queue_t`队列，可通过`wait_current_set`将当前进程置为SLEEPING状态并加入队列；或通过`waitup_first`唤醒队首进程，即将此进程置为RUNNABLE状态。等待队列确保了先等待的进程先唤醒。

具体实现信号量时，`down`函数用于尝试减少信号量（P操作），若当前信号量大于零，则直接减少信号量并返回。否则说明信号量不足，此时将当前进程加入等待队列，唤出调度器执行其他RUNNABLE的进程，自己则等待其他进程尝试增加信号量时将其唤醒，唤醒后将自己移出队列。`up`函数用于尝试增加信号量（V操作），若当前队列中没有进程在等待，则直接增加信号量并返回。否则唤醒等待队列中的队首进程。操作等待队列是互斥的，否则可能发生错误，所以以上函数在操作等待队列时会关中断来实现一个临界区。

若要在用户态进程中实现信号量，可为P和V两个操作分别实现一个系统调用，在系统调用中执行上述内核的信号量函数`down`和`up`。用户态进程使用信号量时，除需要通过系统调用进入内核态而造成了更大开销以外，与内核态进程直接使用信号量没有其他不同。

## 练习2

为实现内核级条件变量，需实现以下两个函数：

- `cond_wait`：首先释放`cvp->owner->next`（如有）或`cvp->owner->mutex`锁，让其余进程能够进入临界区。然后进行等待，即先增加`cvp->count`计数，再获取`cvp->sem`锁。等待结束后，恢复`cvp->count`计数。为防止释放锁后，其他进程马上执行完毕，而当前进程还没有获取`cvp->sem`锁，导致无人释放`cvp->sem`锁而发生死锁，执行整个`cond_wait`函数时应关中断（注：此处不是最佳做法，见下文与参考答案的比较，下同）；
- `cond_signal`：若发现有尚在等待的进程（`cvp->count>0`），则首先释放`cvp->sem`使该进程恢复运行。因为同一时间只能有一个进程在临界区运行，所以接下来要锁住自身，即先增加计数`cvp->owner->next_count`，然后获取锁`cvp->owner->next`。待其他进程离开临界区后，此锁被释放，本进程恢复运行，此时还要恢复`cvp->owner->next_count`计数。为了防止释放`cvp->sem`后，恢复执行的进程执行过快，而当前的进程还没有获取`cvp->owner->next`锁，导致无人释放`cvp->owner->next`锁而发生死锁，执行整个`cond_signal`函数时应关中断。

若要在用户态实现条件变量，有两种方案：

1. 添加条件变量的wait和signal两个系统调用，若用户程序要使用条件变量，先通过系统调用进入内核态，然后再调用内核态的`cond_wait`或`cond_signal`函数；
2. 由于可以通过信号量实现条件变量，故可以在用户态的库（`user/lib/`）中实现条件变量。实现中，若需要使用信号量，则通过系统调用进入内核态进行信号量相关的操作。

这两种方法相比，前者切换用户态/内核态的次数较少，额外开销更少；后者不必增加额外的系统调用，可移植性更好。

条件变量不必通过信号量实现。信号量本质上是一个通过计数器控制的等待队列。在条件变量的实现中，使用了信号量`cv->sem`，却重新实现了其中的计数器`cv->count`，造成了冗余。可以在条件变量的实现中直接使用计数器和等待队列，各函数改为如下实现：

- `cond_wait`：首先释放`cvp->owner->next`（如有）或`cvp->owner->mutex`锁（锁的实现是管程而非条件变量的一部分，此处不考虑），让其余进程能够进入临界区。然后进行等待，即先增加`cvp->count`计数，再调用`wait_current_set`将当前进程置为SLEEPING状态并加入队列。等待结束后，恢复`cvp->count`计数；
- `cond_signal`：若发现有尚在等待的进程（`cvp->count>0`），则调用`waitup_first`唤醒队首进程。此后关于`cvp->owner->next`的逻辑不变。

## 总结

### 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别

Lab7只有实现条件变量一项任务，与参考答案的区别如下：

如上文，在`cond_wait`和`cond_signal`中，我为了防止释放其他进程后，其他进程运行过快，而当前进程来不及获取锁而造成死锁，暂时关闭了中断。而参考答案将“增加计数器”一步移到了释放其他进程之前，这样就算当前进程还没获取锁，被释放的进程也可以预先增加此锁对应的信号量，使当前进程就算运行得较慢，也能获取到锁，这样就不必关闭中断了。以下述代码为例：

```c
1 up(&cvp->sem);
2 cvp->owner->next_count++; // If put this before unlocking, we can keep the interruption on
3 down(&cvp->owner->next);
4 cvp->owner->next_count--;
```

若在第一行释放其他进程后，本进程还没执行到第三行获取`cvp->owner->next`锁，被释放的进程就已经错过了释放`cvp->owner->next`锁的机会，就会造成死锁。而若将第二行提前，变为：

```c
1 cvp->owner->next_count++;
2 up(&cvp->sem);
3 down(&cvp->owner->next);
4 cvp->owner->next_count--;
```

被释放的进程始终可以检测到`cvp->owner->next_count>0`，故而会尝试释放`cvp->owner->next`锁，本质上是增加`cvp->owner->next`信号量，使本进程无论如何都可以获得`cvp->owner->next`锁。

在实现哲学家就餐问题时，我的实现与参考答案有少许C语言实现细节上的区别。此外，参考答案多输出了一些提示信息。由于本实验的评分脚本并没有检查哲学家就餐问题的正确性，我无从确定这些提示性输出对于评分是否是必要的。

### 重要知识点

原理课介绍了同步互斥的底层方法：禁用中断、特殊原子操作（如TS）、原子Load/Store，和高级抽象：信号量、管程。在本实验中涉及了利用禁用中断（和等待队列）实现信号量，以及利用信号量实现管程，将底层和高层贯通起来，但没有涉及如何利用原子操作管理同步互斥。
