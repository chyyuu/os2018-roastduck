# Lab 8 Report

## 练习1

函数`sfs_io_nolock`逐块读写一个文件的内容。对于读写范围内的每一个块，函数首先要调用`sfs_bmap_load_nolock`，根据inode中记录的信息，找出此块的实际位置。然后，调用`sfs_buf_op`读写块的一部分，或调用`sfs_block_op`读写一整个块。具体实现中，分以下三步：

1. 若读写的起始地址不在一块的边界上，则读写范围内的第一块是不完整的，需要单独处理。首先找出此块的位置，然后从起始地址开始读写，直到遇到结束地址或者块的边界；
2. 此后，将需要读写若干（≥0）块完整的块。对于这其中每一个块，找出其位置，然后进行整块地读写；
3. 最后，若读写的结束地址不在一块的边界上，则读写范围内的最后一块也是不完整的。类似第一步，需要先找出此块的位置，然后从上一块的边界开始读写，直到遇到结束地址。值得注意的是，若读写的起止地址在同一块内，第一步就已经读写完整个需要读写的区间了，第三步不需要重复处理。

### 请在实验报告中给出设计实现“UNIX的PIPE机制”的概要设方案，鼓励给出详细设计方案

可以将管道实现为除SFS和device外的第三类inode。

由于操作系统运行时，可能同时存在很多管道，所以首先需要实现一个机制用于动态分配和查找特定的管道，就如`vfsdev.c`管理设备列表一样。但管道数量较设备更多，增删也更频繁，所以需要一个更高效的分配机制，而不能像`vfsdev.c`一样每次分配和查找都使用线性的遍历。为了更高效地分配新管道的ID，可以像分配进程ID一样维护一个空闲ID区间；为了更高效地查找现有管道，可以实现一个由ID到管道地哈希表。具体地，此机制要支持以下三项功能：

- 创建一个具有唯一ID的管道，并创建一个VFS inode，将此inode的`in_type`设为管道、将`in_info`设为到此管道的指针；
- 通过ID查找一个管道，以供函数`vfs_lookup`使用；
- 删除一个管道并释放其资源，包括对应的VFS inode。

通过上述机制创建或查找管道后，就可以通过VFS在管道上执行通用的文件操作。每个管道应拥有一个FIFO队列作为缓冲区，同时允许一个进程写、另一个进程读。进程对管道的具体操作逻辑如下：

- 写管道时，若缓冲区未满，则写入缓冲区，并唤醒读进程。若管道已满，则等待；
- 读管道时，若缓冲区非空，则读出缓冲区，并唤醒写进程。若管道已空，则等待；
- 关闭进程时，应唤醒对方进程以防死锁。当读写两个进程都关闭了管道后，应释放资源。

实现管道时，还应注意读、写的两个进程应该互斥访问，亦可以实现一个支持并行读写的FIFO机制。

## 练习2

`load_inode`函数可在Lab7基础上实现，有两处不同点：

1. Lab7及其之前的实现中，可执行文件是从内存加载的，而在Lab8中则需要调用`load_icode_read`从文件加载。具体地，有如下三处：
    1. 从文件加载ELF头`elf`。我将其置于栈上的临时buffer `elfBuf`中；
    2. 从文件加载段头`ph`。我将其置于栈上的临时buffer `phBuf`中；
    3. 从文件读取段内容。我将其直接读取到目标加载地址。
2. Lab8中，需要为被加载的程序设置参数（`argc`和`argv`）。各个参数的内容原位于`kargv[i]`指向的临时buffer中，设置参数的过程如下：
    1. 遍历各个参数，将其从`kargv[i]`中读出，压入用户栈；
    2. 在用户栈中，按从最后一个参数到第一个参数的顺序，压入该参数在栈上的地址，成为用户主程序的`char **argv`参数；
    3. 在用户栈中压入参数个数，成为用户主程序的`argc`参数。

### 请在实验报告中给出设计实现基于“UNIX的硬链接和软链接机制”的概要设方案，鼓励给出详细设计方案

硬链接的实现很简单，现有SFS框架已可以支持。若目录D中存在一个硬链接指向文件或目录F，只需在D的inode指向的block中添加F的索引项，就如同F直接存在于目录D中一样。此外，应增加F的inode中的引用计数。

软链接实为一种文件。若要在目录D中添加指向文件或目录F的软连接L，则在D中添加文件L，并在L中记录F的路径。软连接L作为文件，应有特殊的头部或者扩展名，以便文件系统将其识别为软连接，而非普通文件。修改SFS的文件查找函数`sfs_lookup`为：当在路径中识别出软连接时，读取该链接以获得被指向文件或目录的地址，然后从该地址开始继续查找。

## 总结

### 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别

- `sfs_io_nolock`中，若在调用`sfs_bmap_load_nolock`、`sfs_buf_op`或`sfs_block_op`时发生了错误，参考答案直接返回了被调用函数的错误码。我也进行了错误判断，但由于不知道错误码的规范是什么，故没有返回特定错误码；
- `load_icode`中，若读取ELF时发生错误，参考答案返回的是I/O相关错误码，我返回的是`-E_INVAL_ELF`。我认为参考答案更合理；
- `load_icode`中，我忘了关闭文件。（由于我认为这个错误较为严重，故已根据参考答案更正）；
- `load_icode`中，为用户程序设置参数时，参考答案为每一个参数调用了两次`strnlen`，而我只调用了一次，我认为我的实现更高效。

### 重要知识点

关于进程间通信，本次实验涉及的原理课知识点为管道，但未涉及信号、消息队列和共享内存。

关于文件系统，虽然本次实验需要编写的代码只涉及关于inode的少量操作，但在调试和做思考题的过程中，需要了解从底层具体文件系统（SFS）中的数据块组织，到虚拟文件系统中的文件、目录和链接，再到上层进程中的文件描述符和打开的文件等一系列知识点。除此之外，本实验还未涉及的知识点还有：文件缓存、文件分配、空闲空间管理和RAID。
