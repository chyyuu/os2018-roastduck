# Lab 8 Report

## 练习1

函数`sfs_io_nolock`逐块读写一个文件的内容。对于读写范围内的每一个块，函数首先要调用`sfs_bmap_load_nolock`，根据inode中记录的信息，找出此块的实际位置。然后，调用`sfs_buf_op`读写块的一部分，或调用`sfs_block_op`读写一整个块。具体实现中，分以下三步：

1. 若读写的起始地址不在一块的边界上，则读写范围内的第一块是不完整的，需要单独处理。首先找出此块的位置，然后从起始地址开始读写，直到遇到结束地址或者块的边界；
2. 此后，将需要读写若干（≥0）块完整的块。对于这其中每一个块，找出其位置，然后进行整块地读写；
3. 最后，若读写的结束地址不在一块的边界上，则读写范围内的最后一块也是不完整的。类似第一步，需要先找出此块的位置，然后从上一块的边界开始读写，直到遇到结束地址。值得注意的是，若读写的起止地址在同一块内，第一步就已经读写完整个需要读写的区间了，第三步不需要重复处理。

### 请在实验报告中给出设计实现“UNIX的PIPE机制”的概要设方案，鼓励给出详细设计方案

可以将管道实现为除SFS和device外的第三类inode。

由于操作系统运行时，可能同时存在很多管道，所以首先需要实现一个机制用于动态分配和查找特定的管道，就如`vfsdev.c`管理设备列表一样。但管道数量较设备更多，增删也更频繁，所以需要一个更高效的分配机制，而不能像`vfsdev.c`一样每次分配和查找都使用线性的遍历。为了更高效地分配新管道的ID，可以像分配进程ID一样维护一个空闲ID区间；为了更高效地查找现有管道，可以实现一个由ID到管道地哈希表。具体地，此机制要支持以下三项功能：

- 创建一个具有唯一ID的管道，并创建一个VFS inode，将此inode的`in_type`设为管道、将`in_info`设为到此管道的指针；
- 通过ID查找一个管道，以供函数`vfs_lookup`使用；
- 删除一个管道并释放其资源，包括对应的VFS inode。

通过上述机制创建或查找管道后，就可以通过VFS在管道上执行通用的文件操作。每个管道应拥有一个FIFO队列作为缓冲区，同时允许一个进程写、另一个进程读。进程对管道的具体操作逻辑如下：

- 写管道时，若缓冲区未满，则写入缓冲区，并唤醒读进程。若管道已满，则等待；
- 读管道时，若缓冲区非空，则读出缓冲区，并唤醒写进程。若管道已空，则等待；
- 关闭进程时，应唤醒对方进程以防死锁。当读写两个进程都关闭了管道后，应释放资源。
