# Lab 6 Report

## 练习1

### 请理解并分析`sched_class`中各个函数指针的用法，并结合Round Robin调度算法描ucore的调度执行过程

`sched_class`各函数功能如下：

- `init`：初始化调度器。在RR算法中，创建了一个空的队列；
- `enqueue`：将一个新的RUNNABLE进程加入调度器。在RR算法中，将此进程加入队列；
- `dequeue`：将一个不再是RUNNABLE的进程移出调度器。在RR算法中，将此进程移出队列；
- `pick_next`：在所有RUNNABLE进程中选取下一个要运行的。在RR算法中，返回队首进程；
- `proc_tick`：在时钟中断时需要进行的操作。在RR算法中，减少当前进程的可用时间片，并在时间片用尽时置`need_resched`。

调度器框架的整体运行流程如下：初始化后，随时可以通过`enqueue`加入新的RUNNABLE进程到调度器。每个时钟中断时，调用`proc_tick`进行处理，处理后检查当前进程是否用尽时间片（即`need_resched==1`）。若是，则进行如下调度：如果当前进程还没运行完，即还处于RUNNABLE状态，则通过`enqueue`将其重新加入调度器。然后，通过`pick_next`从调度器中取出下一个要运行的进程，并通过`enqueue`将其从调度器中移出，最后将上下文切换至该进程。

### 请在实验报告中简要说明如何设计实现“多级反馈队列调度算法”

为了实现此算法，需要为每个优先级各建立一个队列，用于在优先级内部流转时间片，并使用一个数组记录各优先级整体剩余的时间片（由于优先级的数量是固定的，故不必使用链表）。还需使用一个全局变量，记录当前所运行进程的优先级。`sched_class`各函数实现如下：

- `init`：初始化上述各变量；
- `enqueue`：若被加入的进程是当前进程，说明此进程刚刚用完时间片，却没有运行完，则将其加入“当前所运行进程优先级”变量减一优先级（若无，则不减）所对应的队列。若被加入的进程不是当前进程，则说明此进程是新进程，则当作最高优先级处理，因为算法会自动向下调整其优先级；
- `dequeue`：将某进程移出其所在优先级的队列；
- `pick_next`：若当前队列的时间片用完了，则返回下一个（若无，则第一个）优先级的队首进程，并更新“当前所运行进程优先级”变量。否则，说明是此进程的时间片用完了，返回当前优先级队列的队首进程；
- `proc_tick`：分别减少当前优先级和当前进程的剩余时间片，若两个中任意一个被减为零，则置当前进程的`need_resched`为1，等待调度。

## 练习2

`sched_class`各函数实现如下：

- `init`：初始化链表、斜堆和进程计数器；
- `enqueue`：将新的RUNNABLE进程加入链表和斜堆，更新计数器，设置进程的可用时间片，以及进程到调度器的引用；
- `dequeue`：从链表和斜堆中删除要删除的进程，并更新计数器；
- `pick_next`：从斜堆中找出stride最小的进程，使其stride增加其步长（pass）`BIG_STRIDE / priority`，然后返回该进程。

此外，我将最大步长`BIG_STRIDE`设为60，理由是用户程序只使用了不超过6的优先级，60足以整除1~6而不影响精度，又不至于过大而使`stride`容易溢出。

## 总结

### 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别

Lab6只有实现Stride调度算法一项任务，与参考答案的区别如下：

- 参考答案按宏的定义，只实现了链表和斜堆之一；而我由于不知道程序其他部分是否需使用链表，对斜堆和链表均进行了维护，但只是用了斜堆查找应占用CPU时间的进程。由于链表的插入和删除操作是O(1)的，我的实现并不会过于影响性能；
- 参考答案中将`BIG_STRIDE`设为`0x7FFFFFFF`，此数足够大，以保证使用更大`priority`值时步长的精度。由于程序查找最小stride时并不是直接查找最小值，而是使用比较器`proc_stride_comp_f`在各进程的stride间进行比较，而各进程stride的差异不会超过`BIG_STRIDE`，所以不必担心溢出的情况。综上，参考答案选择的`BIG_STRIDE`比我更好；
- 参考答案在`enqueue`中判断若一个进程的剩余时间片若在0和最大值之间，则保留其值，否则才重设为最大时间片，而我将进程的剩余时间片一律设为最大值。参考答案实现的优点在于，操作系统的其他部分可以自由地为不同进程设置不一样的时间片，但μCore实际上没有这么做，所以我和参考答案的实现是等价的。

### 重要知识点

第十五讲的内容均是各种调度算法，其中本实验涉及了时间片轮转、多级反馈队列算法，未涉及先来先服务、短进程优先、最高响应比、公平共享调度算法，也没有涉及实时操作系统的调度和多处理器的调度，但本实验中涉及了原理课未提及的Stride调度算法。原理课侧重讲解各个调度算法的特点，实验侧重于各调度算法的流程。
