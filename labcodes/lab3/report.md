# Lab 3 Report

## 练习1

调用在Lab2实现的`get_pte`函数创建或获取线性地址对应的页表项，若此表项没有被映射到任何一个物理页，则调用`pgdir_alloc_page`函数为其分配一个。值得注意的是，若页表项的存在位为零，并不一定意味着此表项没有对应的物理页，因为它的物理页可能被交换到外存了。只有页表项各个位全为零，才意味着需要为其分配一个新的物理页。

### 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处

存在位为1时，说明此表项在内存中有对应的物理页或次级页表，表项的结构需与x86要求的一致，即其中低7位是各种标志位，高20位表示页或者次级页表的地址。这些标志位中与替换算法直接相关的有：

- 第5位表示已访问。硬件一旦访问某一表项，就会将其已访问位置1。操作系统可以定期检查此位，并在检查后将此位清零，即可统计各表项的使用频率。可以利用此统计结果，实现LFU等基于访问频率的替换算法；
- 第6位表示已写入。硬件一旦写入某表项对应的页，就会将其已写入位置1。操作系统在将某一页替换到外存时可以检查此位，若外存上已有数据，而此页若未被重新写入，则不必将此页再次写入到外存。

存在位为0时，硬件不会检查表项剩下的部分，故软件可以任意使用之。当某页表表项对应的物理页被交换到外存时，μCore使用了第8~31位记录此页被存储在外存上的位置。

### 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

硬件无从知晓μCore正在执行的是普通过程还是缺页服务例程，所以硬件处理过程与处理一般的页访问异常无异：硬件会将访存出现异常时使用的线性地址存入CR2寄存器。然后，执行通用的异常产生流程，包括保存通用寄存器、段选择子、错误码、返回地址等。由于程序一开始就运行在内核态，所以不必切换特权级。最后通过异常/中断向量表找到异常/中断处理例程，执行该例程。

## 练习2

在`map_swappable`函数中将新标记为可置换的页添加到队列末端，在`swap_out_victim`中取出队列首端的页作为将被置换到外存的页即可。

### 如果要在ucore上实现"Extended Clock页替换算法"，请给你的设计方案。现有的`swap_manager`框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案

现有框架中，一个`swap_manager`提供的接口有：`init`、`init_mm`、`tick_event`、`map_swappable`、`set_unswappable`和`swap_out_victim`。为了实现Extended Clock页替换算法，`swap_out_victim`函数接口需要扩展，而其他函数接口不需改变。具体方案如下：

1. `init`返回零即可；
2. `init_mm`中，需初始化算法所需的循环链表，并在`mm_struct`中设置指向该循环链表的指针；
3. `tick_event`返回零即可；
4. `map_swappable`中，应将新标记为可置换的页添加到循环链表中。为确保公平，可将新的页恰好插入到Extended Clock页替换算法的钟表指针之前，即钟表指针需要再转一圈才能访问到新插入的页；
5. `set_unswappable`函数没有被μCore使用。如需实现，将被标记为不可置换的页移出链表即可；
6. `swap_out_victim`是算法核心。此函数中，时钟指针不断检查所指向的页，判断其访问位和写入位，分以下情况处理：
   1. 若该页已被访问、已被写入，则置为未被访问、已被写入，指针移向下一个页；
   2. 若该页已被访问、未被写入，则置为未被访问、未被写入，指针移向下一个页；
   3. 若该页未被访问、已被写入，则置为未被访问、未被写入，并将此页作为要被写入外存的页之一返回，指针移向下一个页；
   4. 若该页未被访问、未被写入，则将此页作为被换出页（victim）返回。

可以看出，`swap_out_victim`不再只是返回一个被换出页，还会返回若干个需要写入到外存的页，所以其函数接口需要调整。执行换出逻辑的`swap_out`函数也需要调整为：

1. 调用`swap_out_victim`获取被换出页和需写入到外存的页地址；
2. 首先检查被换出的页是否是需要被写入的页之一，若是则先写入到外存再从页表中删除，否则直接从页表中删除；
3. 实现并调用一个高效的异步写外存的机制（例如DMA），写入所有要写入外存的页。若没有此异步机制，Extended Clock算法不会比普通的Clock算法优；
4. 刷新TLB。

关于“需要被换出的页的特征是什么”及“在ucore中如何判断具有这样特征的页”，上文已介绍。关于“何时进行换入和换出操作”，与现有μCore实现相同：`do_pgfault`发现正访问的页已被换出时，调用`swap_in`换入，其中`swap_in`需要调用`alloc_pages`分配新页；当`alloc_pages`发现没有足够物理内存空间时，则会调用`swap_out`换出。

## 总结

### 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别

- 练习1中，我将新标记为可置换的页添加到队尾，从队首取出将被换出的页，而参考答案与我的实现相反。这两种实现没有本质区别；
- 练习2中，参考答案检查了`swap_in`和`get_pte`的返回值是否有效，而我没有检查。参考答案更加鲁棒；
- 练习2中，参考答案中进行了`page->pra_addr = addr`赋值，这是多余的，因为在`swap_map_swappable`函数中已经进行过此赋值了。

### 重要知识点

本实验涉及的原理课知识点有：如何实现虚拟存储（包括利用页表记录虚存信息、换入换出流程、缺页异常的处理流程等）、FIFO算法和时钟算法。原理课讲解重在为何实现这些算法，而实验重在如何实现这些算法。

本实验未涉及的知识点有：覆盖技术、其他页置换算法。
