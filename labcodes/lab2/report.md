# Lab 2 Report

## 练习1

所涉及的四个函数改动如下：

- `default_init`：没有改动；
- `default_init_memmap`：没有改动；
- `default_alloc_pages`：此函数分两部分：遍历链表寻找足够大的块、将此块中所需部分取出并将剩余部分插入链表。前一部分原来的实现是正确的，故没有改动。后一部分原来的实现中，是将块中剩余的部分直接插入到了链表头之后，而没有维护链表中块地址的有序性，故改为将块中剩余的部分插入到此块原来所在的位置处。
- `default_free_pages`：此函数分两部分：设置被释放页的属性、将这些页插入链表。前一部分原来的实现是正确的，故没有改动。后一部分改为如下实现：首先将被释放的页作为单独一个块插入链表中相应的位置，然后尽量与其左侧邻接的块合并，再尽量与其右侧邻接的块合并。

### 你的first fit算法是否有进一步的改进空间

改进空间如下：

1. 目前`default_alloc_pages`的实现中，如果申请`n`页，而找到的块只比`n`大一点，例如`n+1`页，那么这剩下的一页也会被重新插入链表。这会使链表中形成大量碎片，影响此后遍历链表的性能。一个合理的改进是：块中剩余的页数大于某个阈值时，才将其重新插入链表；
2. 目前同一个页表的`default_init_memmap`函数只能被执行一次，即不能多次向同一个页表新增可分配空间。如果要支持被执行多次，则需在此函数中遍历链表，将新分配的块插入到链表中适当的位置上，以保证链表中地址的单调性。

## 练习2

首先根据地址的高10位找到页目录表中的目录表项，判断此表项是否已存在。若不存在且需要创建，则分配并初始化一个新页作为二级页表，并在对应的目录表项中设置二级页表的地址和权限。

### 请描述页目录项（Page Director Entry）和页表项（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处

页目录表项与页表项的结构是相同的，从低位到高位，其组成如下：

- 第0位表示此表项是否存在。若此位为零，则此页不在内存中，剩下的31位不再表示原意义，但可用作其他用途。在页表第0位为零时，若此页被交换到磁盘，μCores使用剩下的位表示磁盘上存储此页的位置。
- 第1位表示此表项中的页是只读还是可写。
- 第2位表示用户态是否有权访问此表项中的页。
- 第3位表示写入此页时，是写穿（Write-through）还是写回（Write-back）。
- 第4位表示是否禁用此页的缓存。
- 第5位表示已访问。硬件一旦访问某一表项，就会将其已访问位置1。操作系统可以定期检查此位，并在检查后将此位清零，即可统计各表项的使用情况。可以利用此统计结果，实现LFU等基于访问频率的替换算法。
- 第6位表示已写入。硬件一旦写入某表项对应的页，就会将其已写入位置1。操作系统在将某一页替换到磁盘时可以检查此位，磁盘上已有数据，而此页若未被重新写入，则不必将此页再次写入到磁盘。
- 第7~8位必须为零。
- 第9~11位可供操作系统做任意用途。
- 第12~31位表示页或者次级页表的地址。

### 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

硬件会将访存出现异常时使用的线性地址存入CR2寄存器。然后，执行通用的异常产生流程，包括保存通用寄存器、段选择子、错误码、返回地址等，必要时切换特权级，最后通过异常/中断向量表找到异常/中断处理例程，执行该例程。

## 练习3

首先根据页表项找到对应的物理页，将该页的引用计数减一。若该页的引用计数降为零，说明此不再有任何一个虚页映射到该物理页上，则释放该物理页。然后，清零页表项。由于在页表中删除了项，最后还需清空TLB，避免TLB与页表不一致。

### 数据结构`Page`的全局数组`pages`的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系为何？

`pages`是物理页表，按地址从低到高的顺序存有所有物理页的信息。页表是虚页表，按地址从低到高存有某一页目录表项中所有的虚页信息，包括此虚页映射到哪个物理页，从此物理页地址可以唯一确定一个`pages`表项。页目录表按地址从低到高存有每个页目录项的信息，包括此页目录对应的二级页表的地址。其中，页目录表项与二级页表是一一对应的，但页表项与`pages`表项是多对一关系。

### 如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？

为实现此目标，当开始使用一个新的虚页时，需要给此虚页映射一个与其地址相同的物理页。μCore中最终负责给虚拟页分配物理页的是PMM中`pmm_manager`中的`alloc_pages`函数，即练习1所实现的部分。由于μCore的多态设计，`pmm_manager`是可以按需更换的，故可以实现一个新的`pmm_manager`，将其`alloc_pages`函数定义为返回与虚页地址相同的物理页，并适当修改`pmm_manager`中其他逻辑（例如初始化）即可。这比现有的`pmm_manager`的实现还要简单，因为不再需要通过数据结构维护空闲的物理页。

## 总结

### 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别

实现练习1的`default_free_pages`函数时，我是先插入被释放的页再尝试合并，而答案是先尝试合并再插入被释放的页。这两种做法无本质不同。

其他区别仅限于使用不同的C语句表达同一种逻辑。

### 重要知识点

原理课介绍的段页式存储管理，其中段式存储对应Lab 1，页式存储对应本实验。本实验中涉及的原理课的其他具体知识点有：多级页表、First-Fit算法、在C语言中实现通用的链表数据结构。

本实验中没有涉及的知识点有：最佳匹配和最差匹配算法、碎片整理、反置页表。
